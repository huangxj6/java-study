#### 1、事务有四个特性： ACID
- 原子性（ Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。

- 一致性（ Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。
    - 如线程安全性问题，执行了十次++操作，结果只加了九次，这就是一个不一致的行为。
    - 如转账，A向B转钱，结果必须保证总金额不变，如果变了也是一个不一致的行为。

- 隔离性（ Isolation）：通常来说，一个事务所做的修改在最终提交前对其他事务是不可见的，当然事务的隔离性可通过隔离级别来控制。

- 持久性（ Durability）：一旦事务完成，则其所做的修改就会永久保存到数据库中。即使系统崩溃。

#### 2、事务的隔离级别

- READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读 。比如事务A将金额从100改成为50，在事务A还未提交的情况下，事务B读到了50这个数据后做相应的操作，过一会事务A抛异常回滚了，那么事务B读到50这个数据就是脏读了。

- READ COMMITTED（读提交，SQL Server、Oracle默认级别）：在一个事务中，可以读取到其他事务已经提交的数据。这种读取也可以叫做不可重复读，允许幻读现象的发生。

- REPEATABLE READ（可重复读，MySQL默认级别），在一个事务中，直到事务结束前，都可以反复读取到事务刚开始看到的数据，并一直不会发生变化，避免了脏读、不可重复读和幻读现象的发生。

  - 不允许一个事务修改、删除另一个事务已经读取的数据，也就是说事务A读取一条数据之后，那么就拥有了读锁，此时若有其他的事务想来修改该行数据的话，就必须得到读锁被释放了之后才能执行。

- SERIALIZABLE（可串行化）：最高级别，在每次写数据的时候都要加一个表级的排它锁，读数据的时候加共享锁，可避免脏读、不可重复读、幻读及可重复读，但会大大降数据库的并发能力，产生大量的超时和锁竞争。

#### 3、脏读、不可重复读、幻读

- 脏读：（针对未提交数据）如果一个事务中对数据进行了更新，但事务还没有提交，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。

- 不可重复读：（针对其他提交前后，读取数据**本身**（update、delete）的对比）不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，READ UNCOMMITTED也无法避免不可重复读取的问题。

- 幻读：（针对其他提交前后，读取数据**条数**（insert、delete）的对比） 幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在READ UNCOMMITTED隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，READ UNCOMMITTED同样无法避免幻读的问题。
