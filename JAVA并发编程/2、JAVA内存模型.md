#### 1、JAVA内存模型基础

- **并发编程模型的两个关键问题**

  - 1）线程之间如何通信（线程间以何种机制来交换信息）

    - 共享内存（线程之间共享程序的公共状态，通过写-读内存中的公共状态进行**隐式通讯**）

    - 消息传递（线程之间没有公共状态，线程间必须通过发送消息来进行**显示通讯**）

  - 2）线程之间如何同步（程序中用于控制不同线程间操作发生相对顺序的机制）

    - 在共享内存并发模型中，同步是**显示进行**的。程序员必须显示指定某个方法或某段代码需要在线程之间互斥执行。

    - 在消息传递并发模型中，由于消息的发送必须在消息的接收之前，因此同步是**隐式进行**的

  - JAVA的并发采用的是共享内存模型，所以线程间的通讯总是隐式进行，通信过程对程序员透明。

- **JAVA内存模型的抽象结构**

  - JAVA线程之间的通信由JAVA内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

  - JMM的抽象结构示意图如下所示：

    ![image](/image/THREAD-2-1.png)

  - 线程A与线程B之间要通信的话，必须要经历下面2个步骤

    - 1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。

    - 2）线程B到主内存中去读取线程A之前已更新过的共享变量。

    ![image](/image/THREAD-2-2.png)

  - 从整体上来看，这两个步骤实际上就是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程本地内存之间的交互，来为JAVA程序员提供内存可见性保证。

#### 2、指令重排序

- **概述**

  - 在执行程序时，为了提高性能，编译器和处理器通常会对指令做重排序。

    - 1）编译器优化的重排序：在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

    - 2）指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。

    - 3）内存系统的重排序：由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能是在乱序执行。

  - 从JAVA的源代码到编译到最终实际执行的指令序列，会分别经历下面3种重排序：

    ![image](/image/THREAD-2-3.png)

    - 编译器重排序：JMM的编译器重排序规则会禁止特定类型的编译器重排序。

    - 处理器重排序：JMM的处理器重排序规则会要求JAVA编译器在生成指令序列时，插入内存屏障指令来禁止特定类型的处理器重排序。

  - JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

- **数据依赖性**

  - 两个操作同时访问一个变量，且有一个是写操作，那么这两个操作之间就存在了数据依赖性，如下：

    ![image](/image/THREAD-2-4.png)

  - 这三种情况只要重排序两个操作的执行顺序，那么程序的执行结果就会改变。

  - 编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖的两个操作的执行顺序。

#### 3、顺序一致性

#### 4、volatile的内存语义

#### 5、锁的内存语义

#### 6、final域的内存语义

#### 7、happens-before

#### 8、双重检查锁定与延迟初始化

#### 9、JAVA内存模型综述
